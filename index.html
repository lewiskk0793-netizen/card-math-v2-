<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>å…­å¼µç®—è¡“ - å–®äººç‰ˆ</title>
  <style>
    * {
      box-sizing: border-box;
    }
    
    /* === ä¿®æ­£ï¼šç§»é™¤ body çš„ flex å±…ä¸­ï¼Œé¿å…é ‚éƒ¨è¢«æ¨å‡ºè¦–çª— === */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
      background: #f0f5ff;
      margin: 0;
      padding: 20px 0; /* ä¸Šä¸‹ç•™ç™½ï¼Œç¢ºä¿é ‚éƒ¨å¯è¦‹ */
      color: #333;
      min-height: 100vh;
      display: block; /* ä¸å†ä½¿ç”¨ flex å±…ä¸­ */
    }
    
    .container {
      width: 95%;
      max-width: 800px;
      background: white;
      padding: 20px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      margin: 0 auto; /* æ°´å¹³å±…ä¸­ */
    }
    
    h1 {
      text-align: center;
      color: #2c3e50;
      margin-top: 0;
      font-size: 28px;
    }

    /* è¨ˆåˆ†èˆ‡è¨ˆæ™‚ */
    .score-time {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
      font-weight: bold;
      align-items: center;
    }
    .timer-bar {
      height: 8px;
      background: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 6px;
    }
    .timer-fill {
      height: 100%;
      background: #0984e3;
      width: 100%;
      transition: width 0.1s linear;
    }

    /* ç›®æ¨™å¡ */
    .target-row {
      display: flex;
      justify-content: center;
      margin: 20px 0;
    }
    .target-card {
      width: 70px;
      height: 90px;
      border: 3px solid #d63031;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: bold;
      background: #ffeaa7;
    }

    /* æ‰‹ç‰Œå€ - å›ºå®šé«˜åº¦ + å¡ç‰Œä¸ä¼¸ç¸® */
    .hand-area {
      min-height: 120px;
      height: 120px;
      max-height: 120px;
      margin: 20px 0;
      padding: 20px;
      background: #fafafa;
      border-radius: 12px;
      display: flex;
      flex-wrap: nowrap;
      gap: 12px;
      justify-content: center;
      align-items: center;
      overflow-x: auto; /* å…è¨±æ°´å¹³æ»¾å‹•ï¼ˆæ¥µçª„è¢å¹•ï¼‰*/
      overflow-y: hidden;
    }

    /* å¡ç‰‡ - å›ºå®šå°ºå¯¸ */
    .card {
      width: 60px;          /* â† å›ºå®šå¯¬åº¦ */
      min-width: 60px;      /* â† é˜²æ­¢å£“ç¸® */
      flex-shrink: 0;       /* â† ä¸æ”¶ç¸® */
      height: 90px;
      border: 3px solid #333;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: bold;
      background: white;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      transition: all 0.2s;
    }

    .card.selected-first {
      border-color: #0984e3;
      transform: scale(1.08);
      box-shadow: 0 0 16px rgba(9, 132, 227, 0.6);
    }

    /* é‹ç®—é¸å–® - é ç•™ç©ºé–“ */
    .operator-menu-placeholder {
      height: 70px;
      margin: 20px 0;
    }

    .operator-menu {
      display: none;
      justify-content: center;
      gap: 16px;
      margin: 20px 0;
      flex-wrap: wrap;
      height: 70px;
    }
    .op-btn {
      width: 60px;
      height: 60px;
      font-size: 24px;
      font-weight: bold;
      border: none;
      border-radius: 50%;
      background: #0984e3;
      color: white;
      cursor: pointer;
    }
    .cancel-btn {
      padding: 10px 20px;
      background: #ff7675;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }

    .buttons {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 24px 0;
    }
    button {
      padding: 12px 20px;
      font-size: 18px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      background: #0984e3;
      color: white;
      font-weight: bold;
    }
    #hintBtn { background: #00b894; }
    #nextBtn { background: #fdcb6e; color: #2d3436; }
    #resetBtn { background: #a29bfe; }
    #helpBtn { background: #6c5ce7; }
    #volumeBtn { background: #6c5ce7; color: white; }
    #volumeBtn.muted { background: #636e72; color: #dfe6e9; }

    .message {
      margin-top: 20px;
      padding: 16px;
      border-radius: 10px;
      font-weight: bold;
      text-align: center;
    }
    .success { background: #d5f4e6; color: #00a86b; }
    .error { background: #ffdddd; color: #d63031; }
    .info { background: #e3f2fd; color: #0984e3; }

    /* Start! è¦†è“‹å±¤ */
    .start-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
    }

    .start-overlay.active {
      pointer-events: auto;
    }

    .start-overlay-content {
      position: fixed;
      text-align: center;
      transform: translate(-50%, -50%);
      z-index: 1001;
    }

    .start-game-btn {
      background: #ff6b6b;
      color: white;
      border: none;
      border-radius: 50px;
      padding: 20px 60px;
      font-size: 32px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 8px 25px rgba(255, 107, 107, 0.5);
      transition: all 0.3s ease;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.6);
      overflow: auto;
    }
    .modal-content {
      background-color: #fff;
      margin: 10% auto;
      padding: 20px;
      border-radius: 12px;
      max-width: 500px;
      margin-left: 16px;
      margin-right: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      max-height: 80vh;
      overflow-y: auto;
    }
    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    
    /* æˆåŠŸ/å¤±æ•—å½ˆå‡ºç•«é¢ */
    #successModal, #failureModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      z-index: 2000;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #successModal .modal-content,
    #failureModal .modal-content {
      background: white;
      padding: 30px;
      border-radius: 16px;
      max-width: 400px;
      width: 90%;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      position: relative;
    }

    /* æˆåŠŸç•«é¢æ¨£å¼ */
    #successModal .modal-content {
      background: #d5f4e6;
      border: 3px solid #00a86b;
    }

    #successTimeMessage {
      color: #00a86b;
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 20px;
    }

    #successMessage {
      font-size: 16px;
      margin: 15px 0;
      color: #006400;
    }

    /* å¤±æ•—ç•«é¢æ¨£å¼ */
    #failureModal .modal-content {
      background: #ffebee;
      border: 3px solid #d63031;
    }

    #failureModal h2 {
      color: #d63031;
      margin-top: 0;
      margin-bottom: 20px;
    }

    #failureMessage {
      font-size: 18px;
      margin: 20px 0;
      color: #8B0000;
    }

    /* å‹•ä½œæŒ‰éˆ• */
    .action-buttons {
      display: flex;
      gap: 12px;
      margin-top: 25px;
      width: 100%;
    }

    .action-btn {
      flex: 1;
      padding: 14px 8px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 70px;
    }

    .btn-icon {
      font-size: 24px;
      margin-bottom: 6px;
      display: block;
    }

    .restart-btn {
      background: #6c5ce7;
      color: white;
    }

    .continue-btn {
      background: #00a86b;
      color: white;
    }

    #failureModal .continue-btn {
      background: #d63031;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>å…­å¼µç®—è¡“ - å–®äººç‰ˆ</h1>
    
    <!-- è¨ˆåˆ†èˆ‡è¨ˆæ™‚ -->
    <div class="score-time">
      <div>ğŸ† åˆ†æ•¸: <span id="score">0</span></div>
      <div>â±ï¸ æ™‚é–“: <span id="timeLeft">60</span>s</div>
    </div>
    <div class="timer-bar"><div class="timer-fill" id="timerFill"></div></div>

    <div class="target-row">
      <div class="target-card" id="targetCard">?</div>
    </div>
    <div class="hand-area" id="handArea"></div>
    
    <!-- é ç•™é‹ç®—æŒ‰éˆ•ç©ºé–“ -->
    <div class="operator-menu-placeholder"></div>
    
    <div class="operator-menu" id="operatorMenu">
      <button class="op-btn" onclick="selectOperator('+')">+</button>
      <button class="op-btn" onclick="selectOperator('âˆ’')">âˆ’</button>
      <button class="op-btn" onclick="selectOperator('Ã—')">Ã—</button>
      <button class="op-btn" onclick="selectOperator('Ã·')">Ã·</button>
      <button class="cancel-btn" onclick="cancelSelection()">å–æ¶ˆ</button>
    </div>

    <div class="buttons">
      <button id="hintBtn" onclick="showHint()">æç¤º</button>
      <button id="nextBtn" onclick="newGame()">æ›ä¸€é¡Œ</button>
      <button id="resetBtn" onclick="resetHand()">é‡ä¾†</button>
      <button id="helpBtn" onclick="openInstructions()">ç©æ³•èªªæ˜</button>
      <button id="volumeBtn" onclick="toggleVolume()" title="é–‹é—œéŸ³æ•ˆ">ğŸ”Š</button>
    </div>
    <div id="message" class="message info">ğŸ¯ é»æ“Š "Start!" é–‹å§‹éŠæˆ²</div>
  </div>

  <!-- Start! è¦†è“‹å±¤ -->
  <div class="start-overlay blur" id="startOverlay">
    <div class="start-overlay-content">
      <button class="start-game-btn" onclick="startGame()">Start!</button>
    </div>
  </div>

  <!-- ç©æ³•èªªæ˜ Modal -->
  <div id="instructionsModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeInstructions()">&times;</span>
      <div class="instructions">
        <h2>ğŸ® ç©æ³•èªªæ˜</h2>
        <ul>
          <li><strong>ç›®æ¨™</strong>ï¼šåœ¨ 60 ç§’å…§ç”¨ 5 å¼µç‰Œç®—å‡ºç›®æ¨™å€¼</li>
          <li><strong>æ“ä½œ</strong>ï¼š
            <br>1. é»æ“Šç¬¬ä¸€å¼µå¡
            <br>2. é¸æ“‡é‹ç®—ç¬¦
            <br>3. é»æ“Šç¬¬äºŒå¼µå¡ â†’ è‡ªå‹•è¨ˆç®—
          </li>
          <li><strong>è¦å‰‡</strong>ï¼š
            <br>â€¢ ä¸èƒ½ç”¢ç”Ÿè² æ•¸
            <br>â€¢ é™¤æ³•å¿…é ˆæ•´é™¤ï¼ˆç„¡é¤˜æ•¸ï¼‰
            <br>â€¢ ä¸èƒ½é™¤ä»¥é›¶
            <br>â€¢ <strong>ä¸èƒ½å°‡å…©å¼µç›¸åŒæ•¸å€¼çš„å¡ç‰Œç›¸æ¸›</strong>
          </li>
          <li><strong>è¨ˆåˆ†</strong>ï¼šæˆåŠŸ +100 åˆ† + å‰©é¤˜æ™‚é–“ Ã— 10 åˆ†</li>
        </ul>
        <p style="text-align:center; margin-top:16px;">
          <button onclick="closeInstructions()" style="padding:8px 16px; background:#0984e3; color:white; border:none; border-radius:6px;">
            é–‹å§‹éŠæˆ²ï¼
          </button>
        </p>
      </div>
    </div>
  </div>

  <!-- æˆåŠŸå½ˆå‡ºç•«é¢ -->
  <div id="successModal">
    <div class="modal-content">
      <h2 id="successTimeMessage">ğŸ‰ ä½ èŠ±äº† X ç§’å®Œæˆï¼</h2>
      <p id="successMessage"></p>
      <div class="action-buttons">
        <button class="action-btn restart-btn" onclick="restartGame()">
          <span class="btn-icon">ğŸ”„</span>
          <span>é‡æ–°é–‹å§‹</span>
        </button>
        <button class="action-btn continue-btn" onclick="continueChallenge()">
          <span class="btn-icon">âš¡</span>
          <span>ç¹¼çºŒæŒ‘æˆ°</span>
        </button>
      </div>
    </div>
  </div>

  <!-- å¤±æ•—å½ˆå‡ºç•«é¢ -->
  <div id="failureModal">
    <div class="modal-content">
      <h2>ğŸ’ª å†è©¦ä¸€æ¬¡ï¼</h2>
      <p id="failureMessage"></p>
      <div class="action-buttons">
        <button class="action-btn restart-btn" onclick="restartGame()">
          <span class="btn-icon">ğŸ”„</span>
          <span>é‡æ–°é–‹å§‹</span>
        </button>
        <button class="action-btn continue-btn" onclick="continueChallenge()">
          <span class="btn-icon">âš¡</span>
          <span>ç¹¼çºŒæŒ‘æˆ°</span>
        </button>
      </div>
    </div>
  </div>

  <script>
    // === éŠæˆ²ç‹€æ…‹ ===
    const VALUE_TO_RANK = {1:'A',2:'2',3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'10',11:'J',12:'Q',13:'K'};
    const SUITS = ['â™ ','â™¥','â™¦','â™£'];

    let currentTarget = null;
    let originalHand = [];
    let selectedCard1 = null;
    let selectedOperator = null;
    let score = 0;
    let combo = 0;
    let timeLeft = 60;
    let timer = null;
    let isGameActive = false;
    let currentStep = 0;
    let currentGameSnapshot = null;
    let lastUsedPattern = -1;
    let generatedPuzzles = new Set();
    let volumeEnabled = true;

    // è§£æ³•æ¨¡å¼ï¼ˆä¿æŒä¸è®Šï¼‰
    const SOLUTION_PATTERNS = [
      {
        name: 'all_add_small',
        generate: () => {
          const a = Math.floor(Math.random() * 4) + 2;
          const b = Math.floor(Math.random() * 3) + 1;
          const c = Math.floor(Math.random() * 3) + 1;
          const d = 1;
          const e = 1;
          const ops = [a, b, c, d, e].sort(() => Math.random() - 0.5);
          const target = a + b + c + d + e;
          return { ops, target };
        }
      },
      {
        name: 'multiply_mixed',
        generate: () => {
          const a = Math.floor(Math.random() * 7) + 1;
          const b = Math.floor(Math.random() * 7) + 1;
          const c = Math.floor(Math.random() * 7) + 1;
          const d = 1;
          const e = 1;
          const product = a * b;
          const target = product + c - d - e;
          if (target < 3 || target > 13) throw new Error('Invalid target');
          const ops = [a, b, c, d, e].sort(() => Math.random() - 0.5);
          return { ops, target };
        }
      },
      {
        name: 'divide_exact',
        generate: () => {
          const divisor = Math.floor(Math.random() * 7) + 1;
          const quotient = Math.floor(Math.random() * 7) + 1;
          const dividend = divisor * quotient;
          if (dividend > 13) throw new Error('Invalid dividend');
          const c = Math.floor(Math.random() * 7) + 1;
          const d = 1;
          const e = 1;
          const target = quotient + c - d - e;
          if (target < 3 || target > 13) throw new Error('Invalid target');
          const ops = [dividend, divisor, c, d, e].sort(() => Math.random() - 0.5);
          return { ops, target };
        }
      },
      {
        name: 'big_numbers_challenge',
        generate: () => {
          const ops = Array.from({length: 5}, () => Math.floor(Math.random() * 6) + 8);
          const sum = ops.reduce((a, b) => a + b, 0);
          const target = Math.max(10, Math.min(13, sum - Math.floor(Math.random() * 8)));
          return { ops, target };
        }
      },
      {
        name: 'mixed_big_small',
        generate: () => {
          const big1 = Math.floor(Math.random() * 6) + 8;
          const big2 = Math.floor(Math.random() * 6) + 8;
          const small1 = Math.floor(Math.random() * 7) + 1;
          const small2 = Math.floor(Math.random() * 7) + 1;
          const small3 = 1;
          const target = (big1 - small1) + (big2 - small2) - small3;
          if (target < 3 || target > 13) throw new Error('Invalid target');
          const ops = [big1, big2, small1, small2, small3].sort(() => Math.random() - 0.5);
          return { ops, target };
        }
      },
      {
        name: 'multiply_divide_big',
        generate: () => {
          const factor1 = Math.floor(Math.random() * 7) + 1;
          const factor2 = Math.floor(Math.random() * 7) + 1;
          const product = factor1 * factor2;
          const divisor = Math.floor(Math.random() * 7) + 1;
          const dividend = product * divisor;
          if (dividend > 13) throw new Error('Invalid puzzle');
          const small1 = Math.floor(Math.random() * 7) + 1;
          const small2 = 1;
          const target = product + small1 + small2;
          if (target < 3 || target > 13) throw new Error('Invalid target');
          const ops = [dividend, divisor, factor1, small1, small2].sort(() => Math.random() - 0.5);
          return { ops, target };
        }
      }
    ];

    function getRandomSuit() {
      return SUITS[Math.floor(Math.random() * SUITS.length)];
    }

    function valueToDisplay(value) {
      if (value >= 1 && value <= 13) {
        return VALUE_TO_RANK[value] + getRandomSuit();
      }
      return String(Math.round(value * 100) / 100);
    }

    function createCard(value, isNew = false) {
      const card = document.createElement('div');
      card.className = 'card';
      card.textContent = valueToDisplay(value);
      card.dataset.value = value;
      card.onclick = (e) => {
        e.stopPropagation();
        selectCard(card);
      };
      return card;
    }

    function toggleVolume() {
      volumeEnabled = !volumeEnabled;
      const volumeBtn = document.getElementById('volumeBtn');
      if (volumeEnabled) {
        volumeBtn.textContent = 'ğŸ”Š';
        volumeBtn.classList.remove('muted');
      } else {
        volumeBtn.textContent = 'ğŸ”‡';
        volumeBtn.classList.add('muted');
      }
    }

    function speakText(text) {
      if (!volumeEnabled) {
        setTimeout(() => {
          loadNewGame();
          startTimer();
        }, 400);
        return false;
      }
      
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'en-US';
        utterance.rate = 1.2;
        utterance.pitch = 1.0;
        speechSynthesis.speak(utterance);
        
        setTimeout(() => {
          loadNewGame();
          startTimer();
        }, 1000);
        return true;
      }
      
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator1 = ctx.createOscillator();
        const gain1 = ctx.createGain();
        oscillator1.type = 'sine';
        oscillator1.frequency.value = 880;
        gain1.gain.value = 0.3;
        oscillator1.connect(gain1);
        gain1.connect(ctx.destination);
        oscillator1.start();
        oscillator1.stop(ctx.currentTime + 0.3);
        
        setTimeout(() => {
          const oscillator2 = ctx.createOscillator();
          const gain2 = ctx.createGain();
          oscillator2.type = 'square';
          oscillator2.frequency.value = 440;
          gain2.gain.value = 0.4;
          oscillator2.connect(gain2);
          gain2.connect(ctx.destination);
          oscillator2.start();
          oscillator2.stop(ctx.currentTime + 0.4);
          
          setTimeout(() => {
            loadNewGame();
            startTimer();
          }, 400);
        }, 400);
        return true;
      } catch (e) {
        console.log("Audio not supported");
        setTimeout(() => {
          loadNewGame();
          startTimer();
        }, 400);
        return false;
      }
    }

    function playCalculationSound(operation) {
      if (!volumeEnabled) return;
      
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        switch(operation) {
          case '+':
            createTone(ctx, 523, 0.2, 0);
            createTone(ctx, 587, 0.2, 0.2);
            break;
          case 'âˆ’':
            createTone(ctx, 587, 0.2, 0);
            createTone(ctx, 523, 0.2, 0.2);
            break;
          case 'Ã—':
            createTone(ctx, 523, 0.2, 0);
            createTone(ctx, 659, 0.2, 0);
            createTone(ctx, 784, 0.2, 0.1);
            break;
          case 'Ã·':
            createTone(ctx, 784, 0.15, 0);
            createTone(ctx, 1046, 0.15, 0.15);
            break;
        }
      } catch (e) {
        console.log("Calculation sound not supported");
      }
    }

    function createTone(ctx, frequency, duration, startTime) {
      const oscillator = ctx.createOscillator();
      const gainNode = ctx.createGain();
      oscillator.type = 'sine';
      oscillator.frequency.value = frequency;
      gainNode.gain.value = 0.3;
      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);
      const actualStartTime = ctx.currentTime + startTime;
      oscillator.start(actualStartTime);
      oscillator.stop(actualStartTime + duration);
    }

    function startTimer() {
      if (timer) clearInterval(timer);
      timeLeft = 60;
      isGameActive = true;
      updateTimerUI();
      
      timer = setInterval(() => {
        if (!isGameActive || currentTarget === null) {
          clearInterval(timer);
          timer = null;
          return;
        }
        
        timeLeft--;
        updateTimerUI();
        
        if (timeLeft <= 0) {
          clearInterval(timer);
          timer = null;
          isGameActive = false;
          if (currentTarget !== null && originalHand.length > 0) {
            showFailureScreen();
          }
        }
      }, 1000);
    }

    function updateTimerUI() {
      document.getElementById('timeLeft').textContent = timeLeft;
      const fill = document.getElementById('timerFill');
      if (fill) {
        const percent = Math.max(0, timeLeft / 60 * 100);
        fill.style.width = percent + '%';
        if (timeLeft <= 18) {
          fill.style.background = '#d63031';
        } else {
          fill.style.background = '#0984e3';
        }
      }
    }

    function addScore(base, timeBonus = 0, isCombo = false) {
      let total = base + timeBonus;
      if (isCombo && combo > 1) {
        total = Math.floor(total * (1 + (combo - 1) * 0.2));
      }
      score += total;
      document.getElementById('score').textContent = score;
    }

    function selectCard(card) {
      if (!isGameActive) return;
      
      if (selectedOperator !== null) {
        if (card === selectedCard1) {
          showMessage('ä¸èƒ½èˆ‡è‡ªå·±é‹ç®—ï¼', 'error');
          return;
        }
        performCalculation(card);
        return;
      }

      if (selectedCard1 === null) {
        selectedCard1 = card;
        card.classList.add('selected-first');
        document.getElementById('operatorMenu').style.display = 'flex';
        showMessage('å·²é¸æ“‡ç¬¬ä¸€å¼µå¡ï¼Œè«‹é¸æ“‡é‹ç®—ç¬¦', 'info');
        return;
      }

      if (card === selectedCard1) {
        clearSelection();
        showMessage('å·²å–æ¶ˆé¸æ“‡', 'info');
        return;
      }

      showMessage('è«‹å…ˆé¸æ“‡é‹ç®—ç¬¦ï¼', 'error');
    }

    function selectOperator(op) {
      if (selectedCard1 === null || !isGameActive) {
        showMessage('è«‹å…ˆé¸æ“‡ç¬¬ä¸€å¼µå¡ï¼', 'error');
        return;
      }
      selectedOperator = op;
      showMessage('å·²é¸æ“‡ "' + op + '"ï¼Œè«‹é»æ“Šç¬¬äºŒå¼µå¡', 'info');
    }

    function performCalculation(secondCard) {
      const val1 = parseFloat(selectedCard1.dataset.value);
      const val2 = parseFloat(secondCard.dataset.value);
      let result;

      switch(selectedOperator) {
        case '+': 
          result = val1 + val2; 
          playCalculationSound('+');
          break;
        case 'âˆ’': 
          if (Math.abs(val1 - val2) < 1e-9) {
            showMessage('âŒ ä¸èƒ½å°‡å…©å¼µç›¸åŒæ•¸å€¼çš„å¡ç‰Œç›¸æ¸›ï¼', 'error');
            clearSelection();
            return;
          }
          result = val1 - val2; 
          playCalculationSound('âˆ’');
          break;
        case 'Ã—': 
          result = val1 * val2; 
          playCalculationSound('Ã—');
          break;
        case 'Ã·':
          if (Math.abs(val2) < 1e-9) {
            showMessage('âŒ ä¸èƒ½é™¤ä»¥é›¶ï¼', 'error');
            clearSelection();
            return;
          }
          if (Math.abs(val1 % val2) > 1e-9) {
            showMessage('âŒ é™¤æ³•çµæœå¿…é ˆç‚ºæ•´æ•¸ï¼', 'error');
            clearSelection();
            return;
          }
          result = val1 / val2;
          playCalculationSound('Ã·');
          break;
        default:
          clearSelection();
          return;
      }

      if (result < 0) {
        showMessage('âŒ çµæœä¸èƒ½ç‚ºè² æ•¸ï¼', 'error');
        clearSelection();
        return;
      }

      selectedCard1.remove();
      secondCard.remove();

      const newCard = createCard(result, true);
      document.getElementById('handArea').appendChild(newCard);

      clearSelection();
      currentStep++;

      const remainingCards = document.querySelectorAll('.card');
      if (remainingCards.length === 1) {
        const finalValue = parseFloat(remainingCards[0].dataset.value);
        if (Math.abs(finalValue - currentTarget) < 1e-6) {
          const timeBonus = timeLeft * 10;
          combo++;
          addScore(100, timeBonus, true);
          clearInterval(timer);
          timer = null;
          isGameActive = false;
          showSuccessScreen();
        } else {
          combo = 0;
          clearInterval(timer);
          timer = null;
          isGameActive = false;
          showFailureScreen();
        }
      }
    }

    function cancelSelection() {
      clearSelection();
      showMessage('å·²å–æ¶ˆé¸æ“‡', 'info');
    }

    function clearSelection() {
      if (selectedCard1) {
        selectedCard1.classList.remove('selected-first');
        selectedCard1 = null;
      }
      selectedOperator = null;
      document.getElementById('operatorMenu').style.display = 'none';
    }

    function resetHand() {
      if (!isGameActive) return;
      clearSelection();
      const handArea = document.getElementById('handArea');
      handArea.innerHTML = '';
      for (let i = 0; i < originalHand.length; i++) {
        handArea.appendChild(createCard(originalHand[i]));
      }
      currentStep = 0;
      startTimer();
      showMessage('å·²é‡è¨­æ‰‹ç‰Œ', 'info');
    }

    function showHint() {
      const cards = Array.from(document.querySelectorAll('.card')).map(card => 
        parseFloat(card.dataset.value)
      );
      
      if (cards.length === 0) return 'è«‹å…ˆé¸æ“‡å¡ç‰Œ';
      
      const sortedCards = [...cards].sort((a, b) => a - b);
      const target = currentTarget;
      
      switch(currentStep + 1) {
        case 1:
          if (sortedCards.includes(1)) {
            return 'æœ‰1çš„è©±ï¼Œå…ˆç”¨1å’Œå…¶ä»–æ•¸å­—ç›¸åŠ ';
          }
          if (sortedCards.some(x => x <= 7)) {
            return 'å…ˆåˆä½µå…©å€‹å°æ•¸å­—ï¼ˆâ‰¤7ï¼‰';
          }
          if (sortedCards.some(x => x >= 10)) {
            return 'æœ‰å¤§æ•¸å­—ï¼ˆâ‰¥10ï¼‰æ™‚ï¼Œè€ƒæ…®ç”¨æ¸›æ³•æˆ–é™¤æ³•';
          }
          return 'å°‹æ‰¾å¯ä»¥æ•´é™¤çš„æ•¸å­—å°';
          
        case 2:
          if (sortedCards.some(x => x > 10)) {
            return 'å¤§æ•¸å­—ï¼ˆ>10ï¼‰å»ºè­°ç”¨æ¸›æ³•æˆ–é™¤æ³•';
          }
          if (sortedCards.some(x => x === 1)) {
            return '1å¯ä»¥ç”¨ä¾†å¾®èª¿çµæœ';
          }
          if (sortedCards.some(x => x <= 7)) {
            return 'å°æ•¸å­—ï¼ˆâ‰¤7ï¼‰é©åˆç”¨ä¾†èª¿æ•´çµæœ';
          }
          if (target && sortedCards.some(x => target % x === 0)) {
            return 'å°‹æ‰¾ç›®æ¨™å€¼çš„å› æ•¸';
          }
          return 'å˜—è©¦è£½é€ ç›®æ¨™å€¼çš„å› æ•¸';
          
        case 3:
          if (target && sortedCards.length >= 2) {
            const sum = sortedCards.reduce((a, b) => a + b, 0);
            if (sum === target) {
              return 'æ‰€æœ‰æ•¸å­—ç›¸åŠ ç­‰æ–¼ç›®æ¨™ï¼';
            }
            if (Math.abs(sum - target) <= 2) {
              return 'ç¸½å’Œæ¥è¿‘ç›®æ¨™ï¼Œèª¿æ•´é‹ç®—ç¬¦';
            }
            if (sortedCards.some(x => x <= 7 && (target - x >= 0))) {
              return 'ç”¨å°æ•¸å­—ï¼ˆâ‰¤7ï¼‰ä¾†å¾®èª¿çµæœ';
            }
            if (sortedCards.some(x => x * 2 === target || x * 3 === target)) {
              return 'æœ‰æ•¸å­—æ˜¯ç›®æ¨™å€¼çš„ä¸€åŠæˆ–ä¸‰åˆ†ä¹‹ä¸€';
            }
          }
          return 'æª¢æŸ¥æ˜¯å¦èƒ½ç”¨ä¹˜æ³•å¿«é€Ÿæ¥è¿‘ç›®æ¨™';
          
        case 4:
          if (sortedCards.length === 2) {
            const [a, b] = sortedCards;
            const target = currentTarget;
            if (target) {
              if (a + b === target) return 'ç”¨åŠ æ³•ï¼';
              if (Math.abs(a - b) === target) return 'ç”¨æ¸›æ³•ï¼';
              if (a * b === target) return 'ç”¨ä¹˜æ³•ï¼';
              if (b !== 0 && a % b === 0 && a / b === target) return 'ç”¨é™¤æ³•ï¼';
              if (a !== 0 && b % a === 0 && b / a === target) return 'ç”¨é™¤æ³•ï¼ˆäº¤æ›é †åºï¼‰ï¼';
            }
            return 'åªå‰©å…©å¼µå¡ï¼Œè©¦è©¦æ‰€æœ‰é‹ç®—ç¬¦ï¼';
          }
          return 'é€™æ˜¯æœ€å¾Œä¸€æ­¥ï¼Œä»”ç´°è¨ˆç®—ï¼';
          
        default:
          return 'æ­£å¸¸é€²è¡ŒéŠæˆ²';
      }
    }

    function showMessage(text, type) {
      const msg = document.getElementById('message');
      msg.textContent = text;
      msg.className = 'message ' + type;
    }

    const SUCCESS_MESSAGES = [
      "ä½ çœŸæ˜¯æ•¸å­¸å¤©æ‰ï¼",
      "å¤ªç¥äº†ï¼å®Œå…¨æ­£ç¢ºï¼",
      "å®Œç¾è¨ˆç®—ï¼ç„¡å¯æŒ‘å‰”ï¼",
      "æ•¸å­¸å°é”äººå°±æ˜¯ä½ ï¼",
      "ç²¾æº–ç„¡èª¤ï¼å¤ªå²å®³äº†ï¼",
      "è¨ˆç®—è¶…ç´šæº–ç¢ºï¼",
      "ä½ è®“æ•¸å­¸è®Šå¾—è¶…ç°¡å–®ï¼",
      "å®Œç¾è§£é¡Œï¼çœŸæ£’ï¼"
    ];

    const FAILURE_MESSAGES = [
      "æ²’é—œä¿‚ï¼Œå†è©¦ä¸€æ¬¡ï¼",
      "å·®ä¸€é»å°±æˆåŠŸäº†ï¼",
      "ç¹¼çºŒåŠ æ²¹ï¼Œä½ å¾ˆæ£’ï¼",
      "ä¸è¦æ”¾æ£„ï¼Œä¸‹æ¬¡ä¸€å®šè¡Œï¼",
      "å­¸ç¿’å°±æ˜¯ä¸æ–·å˜—è©¦ï¼",
      "ä½ å·²ç¶“å¾ˆæ¥è¿‘äº†ï¼",
      "æ¯å€‹éŒ¯èª¤éƒ½æ˜¯é€²æ­¥çš„æ©Ÿæœƒï¼",
      "ç›¸ä¿¡è‡ªå·±ï¼Œä½ å¯ä»¥çš„ï¼"
    ];

    function playSuccessSound() {
      if (!volumeEnabled) return;
      
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        createTone(ctx, 523, 0.15, 0);
        createTone(ctx, 659, 0.15, 0.15);
        createTone(ctx, 784, 0.15, 0.3);
        createTone(ctx, 1046, 0.2, 0.45);
      } catch (e) {
        console.log("Success sound not supported");
      }
    }

    function playFailureSound() {
      if (!volumeEnabled) return;
      
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        createTone(ctx, 523, 0.2, 0);
        createTone(ctx, 440, 0.2, 0.2);
        createTone(ctx, 392, 0.25, 0.4);
      } catch (e) {
        console.log("Failure sound not supported");
      }
    }

    function showSuccessScreen() {
      playSuccessSound();
      const usedTime = 60 - timeLeft;
      document.getElementById('successTimeMessage').textContent = `ğŸ‰ ä½ èŠ±äº† ${usedTime} ç§’å®Œæˆï¼`;
      const randomMessage = SUCCESS_MESSAGES[Math.floor(Math.random() * SUCCESS_MESSAGES.length)];
      document.getElementById('successMessage').textContent = randomMessage;
      document.getElementById('successModal').style.display = 'flex';
      
      if (currentGameSnapshot) {
        currentGameSnapshot.score = score;
        currentGameSnapshot.timeLeft = timeLeft;
      }
    }

    function showFailureScreen() {
      playFailureSound();
      const randomMessage = FAILURE_MESSAGES[Math.floor(Math.random() * FAILURE_MESSAGES.length)];
      document.getElementById('failureMessage').textContent = randomMessage;
      document.getElementById('failureModal').style.display = 'flex';
      
      if (currentGameSnapshot) {
        currentGameSnapshot.score = score;
        currentGameSnapshot.timeLeft = timeLeft;
      }
    }

    function continueChallenge() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      
      document.getElementById('successModal').style.display = 'none';
      document.getElementById('failureModal').style.display = 'none';
      
      currentTarget = null;
      originalHand = [];
      score = 0;
      combo = 0;
      currentStep = 0;
      isGameActive = false;
      timeLeft = 60;
      
      document.getElementById('score').textContent = '0';
      document.getElementById('timeLeft').textContent = '60';
      document.getElementById('message').textContent = 'ğŸ¯ é»æ“Šç¬¬ä¸€å¼µå¡ç‰Œï¼';
      document.getElementById('message').className = 'message info';
      
      document.getElementById('handArea').innerHTML = '';
      document.getElementById('targetCard').textContent = '?';
      
      setTimeout(() => {
        loadNewGame();
        startTimer();
      }, 500);
    }

    function restartGame() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      
      document.getElementById('successModal').style.display = 'none';
      document.getElementById('failureModal').style.display = 'none';
      
      if (currentGameSnapshot) {
        currentTarget = currentGameSnapshot.target;
        originalHand = [...currentGameSnapshot.hand];
        score = currentGameSnapshot.score;
        timeLeft = currentGameSnapshot.timeLeft;
      } else {
        currentTarget = null;
        originalHand = [];
        score = 0;
        timeLeft = 60;
      }
      
      isGameActive = false;
      currentStep = 0;
      combo = 0;
      
      document.getElementById('score').textContent = score;
      document.getElementById('timeLeft').textContent = timeLeft;
      document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);
      document.getElementById('message').textContent = 'ğŸ¯ é»æ“Šç¬¬ä¸€å¼µå¡ç‰Œï¼';
      document.getElementById('message').className = 'message info';
      
      const handArea = document.getElementById('handArea');
      handArea.innerHTML = '';
      for (let i = 0; i < originalHand.length; i++) {
        handArea.appendChild(createCard(originalHand[i]));
      }
      
      if (currentTarget !== null) {
        setTimeout(() => {
          startTimer();
        }, 100);
      } else {
        const overlay = document.getElementById('startOverlay');
        overlay.style.display = 'block';
        overlay.classList.add('blur');
        overlay.classList.add('active');
        positionStartButton();
      }
    }

    function isValidPuzzle(puzzle) {
      if (!puzzle.ops.every(x => x >= 1 && x <= 13)) return false;
      if (puzzle.target < 3 || puzzle.target > 13) return false;
      const sum = puzzle.ops.reduce((a, b) => a + b, 0);
      const minPossible = Math.max(1, puzzle.ops.reduce((a, b) => Math.min(a, b), 13));
      if (sum < puzzle.target) return false;
      if (minPossible > puzzle.target && puzzle.ops.length > 1) return false;
      if (puzzle.ops.every(x => x === 1)) return false;
      return true;
    }

    function getPuzzleSignature(puzzle) {
      const sortedOps = [...puzzle.ops].sort((a, b) => a - b);
      return sortedOps.join(',') + '|' + puzzle.target;
    }

    function generateUniquePuzzle() {
      let attempts = 0;
      const maxAttempts = 100;
      
      while (attempts < maxAttempts) {
        let patternIndex;
        do {
          patternIndex = Math.floor(Math.random() * SOLUTION_PATTERNS.length);
        } while (patternIndex === lastUsedPattern && SOLUTION_PATTERNS.length > 1);
        
        lastUsedPattern = patternIndex;
        const pattern = SOLUTION_PATTERNS[patternIndex];
        
        try {
          const puzzle = pattern.generate();
          if (isValidPuzzle(puzzle)) {
            const signature = getPuzzleSignature(puzzle);
            if (!generatedPuzzles.has(signature)) {
              generatedPuzzles.add(signature);
              return puzzle;
            }
          }
        } catch (e) {}
        
        attempts++;
      }
      
      return generateFallbackPuzzle();
    }

    function generateFallbackPuzzle() {
      if (Math.random() < 0.3) {
        const ops = Array.from({length: 5}, () => Math.floor(Math.random() * 6) + 8);
        const sum = ops.reduce((a, b) => a + b, 0);
        const target = Math.max(10, Math.min(13, sum - Math.floor(Math.random() * 8)));
        return { ops, target };
      } else {
        const ops = Array.from({length: 5}, () => Math.floor(Math.random() * 7) + 1);
        const sum = ops.reduce((a, b) => a + b, 0);
        const target = Math.max(3, Math.min(13, sum - Math.floor(Math.random() * 4)));
        if (ops.every(x => x === 1)) {
          ops[0] = 2;
          target = Math.max(3, Math.min(13, ops.reduce((a, b) => a + b, 0) - Math.floor(Math.random() * 2)));
        }
        return { ops, target };
      }
    }

    function loadNewGame() {
      combo = 0;
      currentStep = 0;
      
      const p = generateUniquePuzzle();
      currentTarget = p.target;
      originalHand = [...p.ops];
      document.getElementById('targetCard').textContent = valueToDisplay(currentTarget);

      const handArea = document.getElementById('handArea');
      handArea.innerHTML = '';
      for (let i = 0; i < p.ops.length; i++) {
        handArea.appendChild(createCard(p.ops[i]));
      }

      clearSelection();
      showMessage('ğŸ¯ é»æ“Šç¬¬ä¸€å¼µå¡ç‰Œï¼', 'info');
      
      currentGameSnapshot = {
        target: currentTarget,
        hand: [...originalHand],
        score: score,
        timeLeft: timeLeft
      };
    }

    // âœ… é—œéµï¼šStart! æŒ‰éˆ•å®šä½ï¼ˆä½¿ç”¨ fixed + getBoundingClientRectï¼‰
    function positionStartButton() {
      const handArea = document.querySelector('.hand-area');
      const overlayContent = document.querySelector('.start-overlay-content');
      
      if (!handArea || !overlayContent) return;
      
      const rect = handArea.getBoundingClientRect();
      overlayContent.style.left = (rect.left + rect.width / 2) + 'px';
      overlayContent.style.top = (rect.top + rect.height / 2) + 'px';
    }

    window.addEventListener('resize', () => {
      if (document.getElementById('startOverlay').classList.contains('active')) {
        setTimeout(positionStartButton, 50);
      }
    });

    window.addEventListener('scroll', () => {
      if (document.getElementById('startOverlay').classList.contains('active')) {
        setTimeout(positionStartButton, 50);
      }
    });

    function startGame() {
      speakText("Ready? Go!");
      const overlay = document.getElementById('startOverlay');
      overlay.classList.remove('blur');
      overlay.classList.remove('active');
      setTimeout(() => {
        overlay.style.display = 'none';
      }, 500);
    }

    function newGame() {
      loadNewGame();
      startTimer();
    }

    function openInstructions() {
      document.getElementById('instructionsModal').style.display = 'block';
    }
    
    function closeInstructions() {
      document.getElementById('instructionsModal').style.display = 'none';
    }
    
    window.onclick = function(event) {
      const modal = document.getElementById('instructionsModal');
      if (event.target === modal) closeInstructions();
    };

    document.addEventListener('DOMContentLoaded', () => {
      currentTarget = null;
      originalHand = [];
      score = 0;
      combo = 0;
      currentStep = 0;
      isGameActive = false;
      timeLeft = 60;
      timer = null;
      currentGameSnapshot = null;
      volumeEnabled = true;
      
      document.getElementById('score').textContent = '0';
      document.getElementById('timeLeft').textContent = '60';
      document.getElementById('targetCard').textContent = '?';
      document.getElementById('handArea').innerHTML = '';
      document.getElementById('message').textContent = 'ğŸ¯ é»æ“Š "Start!" é–‹å§‹éŠæˆ²';
      
      document.getElementById('successModal').style.display = 'none';
      document.getElementById('failureModal').style.display = 'none';
      document.getElementById('instructionsModal').style.display = 'none';
      
      const overlay = document.getElementById('startOverlay');
      overlay.classList.add('active');
      positionStartButton();
    });
  </script>
</body>
</html>
